<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>potapenko.dev</title>
  
  <link rel="stylesheet" href="/assets/css/style.css">
  <script src="/assets/js/script.js" defer></script>
  <script src="/assets/js/survey-data.js"></script>
  <style>
    /* Survey specific styles extending your existing theme */
    .survey-container {
      margin-top: 120px;
      padding: 2rem;
      min-height: calc(100vh - 200px);
    }

    .survey-title {
      color: rgb(228, 228, 228);
      font-family: Calibri;
      margin: 1;
      padding: 1;
      font-size: 2.5rem;
      text-shadow: 
       -2px -2px 0 rgb(23, 39, 39), 
        2px -2px 0 rgb(23, 39, 39),
       -2px 2px 0 rgb(23, 39, 39), 
        2px 2px 0 rgb(23, 39, 39);
      text-align: center;
      margin-bottom: 2rem;
    }

    /* Hierarchical folder structure */
    .folder-section {
      margin-bottom: 1rem;
    }

    .folder-header {
      color: rgb(228, 228, 228);
      font-family: Calibri;
      margin: 0.5rem 0;
      padding: 0.5rem;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }

    .folder-header:hover {
      background: rgba(0, 123, 255, 0.2);
      transform: translateX(10px);
    }

    /* Bullet point system */
    .bullet-point {
      position: relative;
      padding-left: 1.5rem;
    }

    .bullet-point::before {
      content: "‚óè";
      color: #007bff;
      position: absolute;
      left: 0;
      top: 0;
      font-size: 1.2em;
    }

    /* Hierarchical headings */
    h1.folder-header {
      font-size: 2rem;
      padding-left: 0.5rem;
    }

    h2.folder-header {
      font-size: 1.7rem;
      padding-left: 2rem;
    }

    h3.folder-header {
      font-size: 1.4rem;
      padding-left: 4rem;
    }

    h4.folder-header {
      font-size: 1.2rem;
      padding-left: 6rem;
    }

    /* Image grid layout */
    .images-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
      gap: 2rem;
      margin: 1rem 0;
      padding-left: 2rem;
    }

    /* Image survey cards with light gray transparent background */
    .image-survey-card {
      background: rgba(128, 128, 128, 0.5); /* Light gray 50% transparent */
      border-radius: 15px;
      padding: 1rem;
      border: 2px solid transparent;
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: row;
      gap: 1rem;
    }

    /* Rainbow border from your styles */
    .image-survey-card {
      animation: borderColorChange 5s infinite;
      animation-fill-mode: forwards;
      border: 2px solid;
    }

    .image-survey-card:hover {
      transform: scale(1.02);
    }

    .image-container {
      flex: 0 0 200px;
    }

    .image-survey-card img {
      width: 200px;
      height: 200px;
      object-fit: contain;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
    }

    .image-filename {
      color: white;
      font-family: Calibri;
      font-size: 0.9rem;
      margin-top: 0.5rem;
      word-break: break-word;
      text-align: center;
    }

    /* Survey controls on the right side */
    .survey-controls {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      justify-content: flex-start;
      padding-top: 1rem;
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .checkbox-row input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: #007bff;
    }

    .checkbox-row label {
      color: white;
      font-family: Calibri;
      font-size: 0.9rem;
    }

    /* Text inputs with black transparent background and rounded edges */
    .text-input {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #555;
      border-radius: 8px;
      padding: 0.5rem;
      color: white;
      font-family: Calibri;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
      transition: border-color 0.3s ease;
    }

    .text-input:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
    }

    .text-input::placeholder {
      color: #aaa;
    }

    /* Name textbox - one line, 20 characters */
    .name-input {
      height: 2rem;
      width: 100%;
      max-width: 300px;
    }

    /* Description textbox - same width, 40 words max */
    .description-input {
      height: 4rem;
      width: 100%;
      max-width: 300px;
      resize: vertical;
      max-height: 8rem;
    }

    /* Custom scrollbar styling for description textareas */
    .description-input::-webkit-scrollbar {
      width: 8px;
      background: transparent;
    }

    .description-input::-webkit-scrollbar-track {
      background: transparent;
      border-radius: 10px;
    }

    .description-input::-webkit-scrollbar-thumb {
      background: #1e3a8a;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .description-input::-webkit-scrollbar-thumb:hover {
      background: #2563eb;
    }

    /* Firefox scrollbar styling */
    .description-input {
      scrollbar-width: thin;
      scrollbar-color: #1e3a8a transparent;
    }

    /* Fixed submit button with rainbow styling */
    .submit-button {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      font-size: 18px;
      padding: 12px 24px;
      border: 2px solid;
      border-radius: 18px;
      background: transparent;
      cursor: pointer;
      font-family: Calibri;
      animation: rainbowText 5s linear infinite, rainbowBorder 5s linear infinite;
      text-decoration: none;
      transition: background 0.3s ease-in-out, transform 0.3s ease-in-out, color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
      color: rgba(255, 255, 255, 0.718);
      z-index: 1000;
    }

    .submit-button:hover {
      background: linear-gradient(45deg, #1118537c, #29687c86);
      transform: scale(1.1);
      color: white;
      box-shadow: 0 0 20px rgba(0, 123, 255, 0.3);
    }

    /* Clear button styling */

    /* Clear button styling */
    .clear-button {
      position: fixed;
      bottom: 2rem;
      right: 13rem;
      font-size: 16px;
      padding: 10px 20px;

      border-radius: 18px;
      background: transparent;
      cursor: pointer;
      font-family: Calibri;
      animation: rainbowText 5s linear infinite, rainbowBorder 5s linear infinite;
      text-decoration: none;
      transition: background 0.3s ease-in-out, transform 0.3s ease-in-out, color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
      color: rgba(255, 255, 255, 0.718);
      transition: background 0.3s ease-in-out, transform 0.3s ease-in-out, color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
      z-index: 1000;
    }

    .clear-button:hover {
      background: linear-gradient(45deg, #582c2c7c, #c74e4e67);
      transform: scale(1.1);
      color: rgb(255, 255, 255);
      box-shadow: 0 0 20px rgba(255, 124, 124, 0.121);
    }

    /* Expand all button */
    .expand-all-button {
      position: fixed;
      top: 4rem;
      right: 20px;
      font-size: 18px;
      padding: 12px 24px;
      border: 2px solid;
      border-radius: 18px;
      background: transparent;
      cursor: pointer;
      font-family: Calibri;
      animation: rainbowText 5s linear infinite, rainbowBorder 5s linear infinite;
      text-decoration: none;
      transition: background 0.3s ease-in-out, transform 0.3s ease-in-out, color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
      color: rgba(255, 255, 255, 0.718);
      z-index: 1001;
    }

    .expand-all-button:hover {
      background: linear-gradient(45deg, #4a1a4a7c, #7a4a7a86);
      transform: scale(1.1);
      color: white;
      box-shadow: 0 0 20px rgba(147, 0, 211, 0.3);
    }

    /* Mobile responsiveness for expand button */
    @media (max-width: 768px) {
      .expand-all-button {
        top: 3.5rem;
        right: 15px;
        padding: 10px 20px;
        font-size: 14px;
      }
    }

    /* Collapsible content */
    .collapsible-content {
      display: none;
      animation: fadeIn 0.3s ease-in-out;
    }

    .collapsible-content.show {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .images-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        padding-left: 0.5rem;
        padding-right: 0.5rem;
      }

      .image-survey-card {
        flex-direction: column;
        padding: 0.5rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .image-survey-card.zoomed {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(1.5);
        z-index: 2000;
        background: rgba(128, 128, 128, 0.95);
        backdrop-filter: blur(10px);
        max-width: 90vw;
        max-height: 90vh;
        overflow: auto;
      }

      .image-container {
        flex: none;
        width: 100%;
      }

      .image-container img {
        width: 100%;
        height: auto;
        max-height: 120px;
        object-fit: cover;
      }

      .zoomed .image-container img {
        max-height: none;
        height: auto;
      }

      .card-content {
        flex: 1;
        min-height: 80px;
      }

      .card-content h3 {
        font-size: 12px;
        margin: 0.3rem 0;
      }

      .card-content .description {
        font-size: 10px;
        line-height: 1.2;
      }

      .name-input, .description-input {
        font-size: 10px;
        padding: 0.3rem;
      }

      .zoomed .card-content h3 {
        font-size: 18px;
      }

      .zoomed .card-content .description {
        font-size: 14px;
      }

      .zoomed .name-input, .zoomed .description-input {
        font-size: 14px;
        padding: 0.5rem;
      }

      /* Overlay for zoomed images */
      .zoom-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1999;
        display: none;
      }

      .zoom-overlay.active {
        display: block;
      }
      
      .survey-container {
        padding: 1rem;
        margin-top: 80px;
      }
      
      .submit-button {
        bottom: 1rem;
        right: 1rem;
        font-size: 16px;
        padding: 10px 20px;
      }

      .clear-button {
        bottom: 1rem;
        right: 8rem;
        font-size: 14px;
        padding: 8px 16px;
      }

      .image-survey-card {
        flex-direction: column;
      }

      .image-container {
        flex: none;
        align-self: center;
      }
    }
  </style>
</head>

<body class="page-about">
  <div id="header-placeholder"></div>
  <div id="footer-placeholder"></div>
  <script src="/assets/js/include.js"></script>

  <main class="survey-container">
    <h1 class="survey-title">Game Pixel Art Survey</h1>
    
    <!-- Expand/Collapse All Button -->
    <button class="expand-all-button" onclick="toggleAllSections()">Expand All</button>
    
    <div id="survey-content">
      <!-- Content will be dynamically generated by JavaScript -->
    </div>
    <div id="survey-status" style="margin-top:1rem;color:#ccc" aria-live="polite"></div>
  </main>

  <button class="submit-button" onclick="submitSurvey()">Submit Survey</button>
  <button class="clear-button" onclick="clearAllFields()">Clear All</button>
  
  <!-- Zoom overlay for mobile -->
  <div class="zoom-overlay" onclick="closeZoom()"></div>

  <footer class="footer">
    <button class="icon-button" id="btnGit" aria-label="Go to GitHub">
      <img src="/images/github logo.png" alt="GitHub Icon">
    </button>
    <button class="icon-button" id="btnLink" aria-label="Go to LinkedIn">
      <img src="/images/linkedin.png" alt="LinkedIn Icon">
    </button>
    <button class="icon-button" id="btnMozaic" aria-label="Go to MyMozaic">
      <img src="/images/mymozaic.png" alt="MyMozaic Icon">
    </button>
    <button class="icon-button" id="btnCodePen" aria-label="Go to CodePen">
      <img src="/images/codepen-min.png" alt="CodePen Icon">
    </button>
    <script>
      document.getElementById("btnGit").addEventListener("click", function() {
        window.location.href = "https://github.com/JosephPotapenko";
      });
      document.getElementById("btnLink").addEventListener("click", function() {
        window.location.href = "https://www.linkedin.com/in/joseph-potapenko-1788a7316/";
      });
      document.getElementById("btnMozaic").addEventListener("click", function() {
        window.location.href = "https://www.mymozaic.com/josephpotapenko";
      });
      document.getElementById("btnCodePen").addEventListener("click", function() {
        window.location.href = "https://codepen.io/JosephPotapenko";
      });
    </script>
  </footer>

  <script>
    // Descriptions database from deduplicated_lines.txt
    const descriptionsDatabase = {
      "Almonds": "Harvested in early spring near the Judean hills, almonds offer rich flavor and are used in trade and temple offerings.",
      "Amazonite": "This blue-green stone, traded from Sinai, is prized for its calming effect and clarity. It is commonly set into jewelry.",
      "Amber_Locket": "This locket contains a polished amber gem strung on flax cord. It is worn as a token of protection.",
      "Amber": "Golden amber, brought by traders from the north, glows softly when warmed. It serves as a decorative charm.",
      "Amethyst": "A deep violet stone worn by scribes and nobles. It's set into rings and seals and valued for its beauty.",
      "Ancient_Egyptian_Earrings": "Gold earrings with lotus motifs, crafted in the Egyptian Delta. These symbolize rebirth and beauty.",
      "Ancient_Fish_Hook": "A simple bronze fish hook used along the Sea of Galilee. It helps sustain local villages and daily life.",
      "Ancient_Flying_Toy": "Carved from wood and shaped like a bird, this toy flutters when tossed. Children play with it near village walls.",
      "Ancient_Hebrew_Dradle": "A spinning wooden top etched with early Hebrew letters. Children use it to learn script through play.",
      "Ancient_Hebrew_Necklace": "Woven from flax cord and adorned with etched stones, this necklace bears blessings and symbols of family lineage.",
      "Ancient_Hebrew_Ring": "A bronze ring bearing a carved family seal. Used to stamp wax or clay, it signifies identity and heritage.",
      "Ancient_Hebrew_RIng": "A bronze ring etched with tribal emblems. Likely worn by a household head, it seals documents and safeguards one's name.",
      "Ancient_Hebrew_Spoon": "Carved from olivewood, this spoon is used in meals and temple rites.",
      "Ancient_Israeli_Bracelet": "A bronze bracelet twisted into delicate patterns. Worn during ceremonies, it reflects craftsmanship and tribal identity.",
      "Ancient_Scroll": "A parchment scroll containing tribal records or laws. Preserved in clay jars, it is used by scribes and elders.",
      "Ancient_tablet_map": "A clay tablet etched with trade routes linking Hazor and Megiddo. Used by merchants and scouts.",
      "Antidote_Remedy": "A mix of hyssop, honey, and crushed seeds. Known in village traditions for cleansing the body.",
      "Apple": "A sweet fruit grown in northern highlands and brought to markets. Eaten fresh or dried during gatherings.",
      "Apricots": "Golden apricots are dried in the Jericho sun and stored for winter. Commonly used in stews or eaten whole.",
      "Aquamarine": "A pale blue stone often worn in amulets and pendants. It is favored for its color and clarity.",
      "Assyrian_Art": "A fragment of stone relief showing a winged beast. Once part of a palace wall, it reflects Assyrian craftsmanship.",
      "Assyrian_Coin": "A bronze coin stamped with symbols of the empire. Passed through many hands in regional trade.",
      "Assyrian_Pot": "A large clay pot with lion motifs. It stores grains, oils, or dried fruit.",
      "Assyrian_stone_Marker": "A heavy stone marked with Akkadian script. It may have once stood on a road or border.",
      "Assyrian_Swinging_Blade": "A weapon hung over gates during sieges. It swings to repel invaders.",
      "Assyrian_Swinging_Spear": "Hung on chains near fortress gates, this spear swings to defend against intruders.",
      "Assyrian_Whip_Handle": "A carved handle used by soldiers or overseers. Its worn grip shows signs of heavy use.",
      "Assyrin_Fish_God_Statue": "A carved image of Dagon, the half-fish god of grain and fertility. It reflects foreign worship practices.",
      "Avacadoes": "A soft green fruit with creamy flesh, prepared by some traders as a curiosity.",
      "Baked_Potatoes__2_": "A seasoned version of baked roots, flavored with herbs and leeks. Popular in highland homes.",
      "Baked_potatoes": "Roasted root vegetables wrapped in clay ovens. Common in village meals during the colder seasons.",
      "Barley_Brew": "A fermented drink made from roasted barley and spring water. Often consumed during feasts or harvest celebrations.",
      "Barley": "A staple grain grown in spring fields. Ground into meal or brewed into drink, it is vital to daily life.",
      "Basket_of_red_plums": "Freshly picked and stored in reed baskets, these juicy red plums are shared during summer gatherings.",
      "Basket_of_Scrolls": "A tightly wrapped collection of early writings. These scrolls contain proverbs, law, or trade records, safeguarded for generations.",
      "Basket_of_stones": "A basket filled with smooth stones for sling practice or marking boundaries. Used by shepherds and young warriors in training.",
      "Bean_Stew": "A warm mixture of lentils, garlic, and herbs simmered in clay pots. Often served during cool evenings.",
      "Beat_Soup": "Made from red root beets, this earthy soup is known to strengthen the body.",
      "Beef_and_beans": "A hearty dish with slow-cooked beef and legumes. Rich in flavor and often shared during communal meals.",
      "Beef_and_Veggies": "This stew of meat, onions, and herbs is common at feasts. A sustaining dish after long labor.",
      "Beef_stew": "Tender cuts of beef stewed with root vegetables. A favored dish in colder seasons.",
      "Beet_Salad": "A chilled dish of chopped beets and herbs in vinegar. Refreshing and served during midyear festivals.",
      "Berries": "Handpicked from the Judean hills, these tart berries provide quick nourishment while traveling.",
      "Beryl_Pendant": "A yellow-green gem set in bronze. Worn by those seeking clarity or protection from envy.",
      "Black_Beauty_Plums": "Deep purple plums with rich sweetness. Preserved or eaten fresh, and prized in early autumn.",
      "Black_Berries": "Found in shaded groves, black berries are small but nourishing.",
      "Black_Olives": "Soaked in brine and cured for weeks, these olives are served with bread or cheese.",
      "Boiled_Greens": "Cooked wild greens flavored with garlic and oil. Commonly eaten during springtime.",
      "Bone_Broth": "Simmered for hours with marrow-rich bones. Known for its nourishing quality.",
      "Bowl_of_Red_Plums": "Juicy plums served in a ceramic bowl. Often offered to honored guests.",
      "Box_of_almonds": "A wooden box filled with roasted almonds. Carried by merchants and travelers.",
      "Box_of_Dates": "Packed with sticky, sweet dates, this box is a favored travel ration.",
      "Bread": "Flat, round loaves baked on hot stones. A daily necessity and comfort.",
      "Broccoli": "A cool-weather plant grown in hillside gardens. Steamed and served with oil.",
      "Broken_Blade": "A fractured weapon once used in battle. Though no longer deadly, it holds a story and may be reforged.",
      "Broken_Hebrew_Bracelet": "A snapped bronze bracelet bearing faded script. Possibly from a tribal elder, its pieces may hold sentimental value.",
      "Bunch_of_Plums": "A cluster of ripe, red plums still attached to the stem. Often shared among workers.",
      "Bushel_of_Grain": "A large woven basket of harvested grain. Used for trade, baking, or brewing.",
      "Butter": "Churned from goat milk in skin pouches, this rich spread adds flavor to simple meals.",
      "Candle_Stick": "A bronze or clay base designed to hold tallow or oil-burning wicks. Common in homes, these illuminate interiors during evening prayers and storytelling.",
      "Carrots": "Cultivated in irrigated garden plots, carrots are sliced and cooked in stews. Their sweetness balances more bitter herbs during seasonal feasts.",
      "Carving_Blade": "A sharp blade used by artisans for shaping wood and ivory. Found in craft districts and among temple workers who fashion ceremonial objects.",
      "Cheese": "Pressed from goat or sheep milk, cheese is wrapped in leaves and stored in caves. Widely traded across Canaan, it is produced in spring and early summer.",
      "Chestnuts": "Collected in forested highlands during late summer. Roasted chestnuts are a common treat and a seasonal delicacy.",
      "Chicken_Broth": "A simple broth made by boiling fowl with leeks and herbs. Often prepared for the elderly or infirm.",
      "Chicken_stew": "A hearty stew simmered with poultry, onions, and wild greens. Cooked in clay pots, it is a communal dish for gatherings.",
      "chicken_tika_masala": "A spiced dish with clear foreign influence, possibly brought by travelers or adapted from eastern trade routes. Prepared with regional herbs and poultry.",
      "Clay_Elephant_Sculpture": "A small figurine, likely a foreign import from eastern trade. Elephants symbolize strength in some distant cultures and are rare in local finds.",
      "Clay_tablet_scroll": "A rolled clay document etched with script, used before parchment became widespread. Holds contracts or divine sayings recorded by scribes.",
      "COncord_Grapes": "A misnamed or symbolic entry; dark grapes were cultivated in vineyards near Hebron and pressed into wine or dried as raisins.",
      "Container_of_Hazelnuts": "A woven pouch holding foraged hazelnuts, often stored for winter or carried by shepherds as a travel ration.",
      "Cooked_Goat": "Roasted or stewed meat from young goats, served during feasts or sacrifices. Goat herding is widespread across the Judean hills.",
      "Cranberry_Basket": "Though cranberries are not native, similar red berries are collected near streams. Carried in baskets and used in sauces and preserves.",
      "Crescent earrings": "Shaped like a waning moon, these bronze earrings may have symbolized fertility or celestial favor in neighboring cultures.",
      "Crescent_earrings": "Earrings shaped like a crescent moon, often linked to fertility symbols or worn as a charm. Popular in both Hebrew and surrounding cultures.",
      "Crushed_Meal": "Ground grain or seeds prepared using a stone mortar. Used as the base for unleavened bread or porridge.",
      "Decorative_Assyrian_Challace": "A ceremonial cup etched with lion and eagle motifs. Likely used in Assyrian rituals or royal banquets.",
      "Decorative_Egyptian_Jar": "A slender jar painted with lotus and falcon patterns. Commonly found in noble households, used for oils or perfumes.",
      "Decorative_Hebrew_Cup": "A finely crafted cup, often shared at weddings or covenant ceremonies. Sometimes etched with ancestral lines or psalms.",
      "Decorative_Hebrew_Pot": "A painted storage pot with tribal motifs. Used for offerings, ritual grains, or sacred water.",
      "Decorative_Throwing_Blade": "A balanced blade engraved with symbols. Both weapon and ornament, used by elite warriors in ceremonies or competitions.",
      "Diamond_Pendant": "While rare in this region, this clear stone is set in bronze. Likely acquired through long trade routes from Kush or India.",
      "dried_fig": "Sweet and wrinkled, this fig is sun-dried on rooftops near Hebron. It sustains travelers and is prized during long treks.",
      "Eggs": "Collected from domestic fowl and wild birds alike. Eaten boiled or mixed into stews, especially during early spring.",
      "Egyptian_Brooch": "Decorated with a scarab motif, this brooch once adorned linen robes. It likely belonged to a noble visiting from the Nile Delta.",
      "Egyptian_Compass": "A device using shadows and the sun's arc. Priests or builders in Egypt used it to align temples and pyramids to celestial paths.",
      "Egyptian_Decorative_Pot": "Painted with blue lotus and falcon wings, this vessel holds perfumes or sacred oils in Egyptian ceremonial chambers.",
      "Egyptian_Decorative_Water_Pitcher": "A slim-necked pitcher used to pour water during purification rituals. Its carvings show Nile reeds and ibis birds.",
      "Egyptian_Embalming_Jar": "One of a set used to store organs during mummification. Carved from alabaster and dedicated to protective gods like Hapi.",
      "Egyptian_Embalming_Oil": "A fragrant mixture of myrrh and spices used in burial rites. Stored in alabaster flasks to preserve sacred bodies.",
      "Egyptian_Oil_Pot": "A small vessel designed for scented oils. Often found in tombs and bathhouses, decorated with delicate blue glazes.",
      "Egyptian_Pendant": "A bronze and lapis charm bearing hieroglyphs. Worn for protection, often invoking deities like Thoth or Isis.",
      "Egyptian_Pitcher": "A tall clay vessel with painted reeds. Used for pouring water during rituals or storing daily provisions.",
      "Egyptian_Pot": "A wide-bellied storage pot with worn inscriptions. Common in households, it holds grains, dates, or oil.",
      "Egyptian_Scalpal": "A bronze tool used in mummification and minor surgery. Its edge is still sharp, bearing signs of sacred tasks.",
      "Egyptian_Sceptre": "A decorative rod of authority bearing falcon engravings. Likely held by a priest or steward in temple processions.",
      "Egyptian_Teapot": "A misnamed vessel‚Äîlikely used for herbal infusions, not tea. Decorated with papyrus stalks and lotus petals.",
      "Egyptian_Urn": "A funerary jar painted with sacred symbols. Often used to hold ashes or offerings to the gods.",
      "Egyptian_Water_Jug": "A heavy jug used for drawing Nile water. Often stored near entrances for ritual cleansing or hospitality.",
      "Emerald": "A deep green gem traded from the Sinai route. It is set into bronze jewelry and worn by elite scribes or merchants.",
      "Falchion": "A curved iron blade used by guards and mercenaries. Found in border towns where conflict often breaks out.",
      "Fancy_Bow": "A laminated bow reinforced with horn and sinew. Often carried by royal escorts or skilled archers from the northern tribes.",
      "Feather_Decor": "Desert bird feathers tied to staffs or garments. Used during tribal ceremonies or to adorn festival processions.",
      "Female_Face_Sculpture_from_Persia": "A carved bust brought by traders from the east. It may have stood in a merchant's home as a sign of foreign trade.",
      "Fig": "Grown along terraced hillsides, figs are dried or eaten fresh. Mentioned in records as a symbol of prosperity and peace.",
      "Fish_1": "Salted and preserved fish caught in the Sea of Galilee. Common in markets near Capernaum and along major trade roads.",
      "Fish_2": "Smoked fish wrapped in fig leaves and stored in baskets. Eaten by travelers and offered at feasts near the lake shores.",
      "Fried_Meat": "Sliced cuts of meat crisped over fire. A treat served during local feasts and in market stalls on holy days.",
      "Fried_Potatoes": "Sliced tubers cooked on hot stones and seasoned with herbs. A humble but favored food in colder regions.",
      "Fried_Vegetables": "Seasonal vegetables pan-cooked with oil. Served during harvest gatherings or sold by traveling vendors.",
      "Garlic": "Braided and dried, garlic is used in stews and stored in cool places. Grown widely around Judean hills.",
      "Goat_Butter": "Churned from fresh milk in skin sacks by shepherds. Spread on bread or used in cooking near Hebron.",
      "Goat_Cheese": "Wrapped in leaves and stored in caves, this cheese is made in early summer and traded in southern markets.",
      "Golden_Chain_of_Assyrian_King": "A thick chain adorned with lion motifs. Taken as tribute or loot from Assyrian raids.",
      "Golden_Tag": "A thin plate used to identify rank or household. Found on garments and within tomb offerings.",
      "Gorbonzo_Beans": "A hardy legume grown in dry soil. Often boiled or mashed and stored for winter meals.",
      "Head_of_Baal": "A broken idol head of a foreign god. Sometimes buried or destroyed during religious reforms.",
      "Healing_Elixir": "A brew of honey and herbs stored in clay flasks. Used by families to treat illness or fatigue.",
      "Hebrew_Archive_Container": "A sealed jar used to store scrolls or tribal documents. Found in caves and elder homes.",
      "Hebrew_Challace": "A finely crafted vessel shared during covenant meals. Decorated with tribal patterns and kept in sacred spaces.",
      "Hebrew_Mortar_and_Pestel": "A stone tool used for grinding grain, herbs, or incense. Common in both homes and temple kitchens.",
      "Hebrew_Oil_Jar": "A tall jar for storing pressed olive oil. Placed beside lamps or used in meal preparations.",
      "Hebrew_Oil_Lamp": "A clay lamp used for light during prayer and study. Filled with olive oil and placed on shelves.",
      "Hebrew_Plate": "A broad clay dish used to hold bread or fruit. Decorated with family patterns and shared during gatherings.",
      "Hebrew_Pot": "A standard vessel for cooking or storage. Found in most households, often blackened by fire.",
      "Hebrew_Smoking_Pot": "A clay pot used to burn incense or dry herbs. The smoke is used in cleansing and ritual settings.",
      "Incense_Burner": "A bronze or clay vessel designed to burn fragrant resins and herbs. Hung on walls or placed on stands, it fills rooms with sacred smoke during prayer and purification rituals.",
      "Hebrew_Urn": "An urn for storing grain, oil, or ashes. Sometimes kept in homes of priests or elders.",
      "Hebrew_Vase": "A decorative vessel often presented at weddings. It carries oil, water, or offerings.",
      "Hebrew_Water_Bason": "A shallow bowl placed near doors for handwashing. Used before meals and communal worship.",
      "Hebrew_Water_Pitcher": "A clay pitcher used to pour water during meals. Found in homes and shared spaces.",
      "Hebrew_Water_Pot": "Used to store clean water drawn from wells. Commonly stored in shaded corners of the home.",
      "Herbal_Elixir": "A mixture of crushed herbs and fruit, steeped and stored in skin pouches. Often consumed during fasts.",
      "Herbal_tea": "Hot water poured over dried herbs. Served to travelers and elders as a refreshing drink.",
      "Hilted_Dual_Blade": "A dual-edged short blade with an ornate hilt. Used by bodyguards or temple watchmen.",
      "Honey_Wafers": "Thin cakes made from flour and honey. Shared during festive days and temple events.",
      "Hunting_dart": "A lightweight dart tipped with bone or bronze. Used for hunting game in open fields.",
      "Impact_Dagger": "A thick dagger meant for breaking through armor. Found on soldiers in border skirmishes.",
      "Ink_well": "A small clay vessel used by scribes. Filled with dark ink made from charcoal or crushed seeds.",
      "Israeli_pot": "A cooking pot made from local red clay. Used over fire pits in village homes.",
      "Israeli_Stone_Marker_": "A carved stone used to mark boundaries or burial places. Some are etched with family symbols.",
      "Jagged_Blade": "A broken weapon with a splintered edge. Still sharp, possibly from a recent battle.",
      "Jar_of_Honey": "A ceramic jar sealed with wax, filled with wild honey. Found near fig orchards and hillsides.",
      "Jar_of_red_plums": "Clay storage packed with preserved plums. Served during feasts or stored for winter.",
      "Kidney_Bean_Bushel": "A bushel of dried red beans collected after the early rains. Traded or stored for stew.",
      "Kings_Orders": "A rolled scroll sealed with a signet ring. Contains commands issued from a distant governor or king.",
      "Lamb_stew": "Meat simmered with herbs and lentils in clay pots. Prepared during sacred gatherings and family meals.",
      "Lamp_oil_jar": "Used to hold oil for lighting lamps. Often placed on shelves in homes or near scrolls.",
      "Lapiz_Lazuli_Pendant": "A blue stone set in bronze and worn on cords. Traded through Syria and admired for its vivid hue.",
      "Large_Egyptian_Pot": "A broad clay vessel from the Nile region, often used to store grain or dried fish in upper-class homes or temple kitchens.",
      "Lavendar_sprigs": "Dried sprigs used to scent garments and homes. Gathered near the Mediterranean coast and tied in bundles with twine.",
      "Legendary_Sword": "A well-forged weapon with ornate detail. Said to have passed between warriors during ancient campaigns near the Jezreel Valley.",
      "Lobster": "Rare along inland trade routes, but occasionally brought from the Mediterranean coast, prepared by boiling in clay pots.",
      "Long_Sword": "A standard infantry weapon forged from iron. Found in battlegrounds and garrisons near fortified cities.",
      "Mackeral": "Caught in the Mediterranean, salted, and transported inland. Served in small portions alongside barley and bread.",
      "Night_fish": "A nocturnal fish caught in deep waters during moonless nights. Known for its silvery scales and tender flesh.",
      "Rainbow_Runner": "A colorful fish with vibrant stripes, found in warm coastal waters. Prized for its beauty and delicate flavor.",
      "Crabs": "Hard-shelled creatures scuttling along the Mediterranean shoreline. Boiled and cracked open to access sweet meat within.",
      "clown_fish": "A small, orange fish with white stripes. Occasionally caught near coral formations and kept as curiosities.",
      "gold_fish": "A rare, golden-scaled fish considered a symbol of prosperity. Sometimes kept in temple pools or noble houses.",
      "ocean_sunfish": "A large, flat fish found in deeper Mediterranean waters. Its unusual shape makes it memorable among fishermen.",
      "seaweed": "Marine vegetation harvested from coastal waters. Dried and used as seasoning or wrapped around other foods.",
      "Man_s_Clay_sculpture_of_Babel": "A small clay figure, possibly representing men from ancient Babel. Found near old ziggurat ruins and cracked by time.",
      "Mandarines": "Bright citrus brought from warmer coastal regions. Peeled and eaten at feasts, especially during early spring.",
      "Mashed_Potatoes": "Boiled root vegetables pounded with oil and herbs. Served hot, especially in colder months in highland regions.",
      "Matza": "Unleavened bread baked on flat stones. Traditionally eaten during sacred observances and remembrance of past deliverance.",
      "Meal_and_herbs": "A mixture of ground barley and wild herbs. Often eaten by field workers and shepherds as a quick, nourishing dish.",
      "meat_and_cheese_dish": "A plate of cooked meat paired with goat cheese. Common at evening meals in village homes or during celebrations.",
      "Medicinal_Tartar": "A paste made from crushed herbs and minerals. Applied to wounds or mixed into drink for healing.",
      "Medicine_Vile": "A small glass or clay vial used to carry crushed roots and sap. Administered in drops by healers and midwives.",
      "Milk_Bottle": "A clay jug sealed with wax or linen, used to store fresh milk from goats or sheep, especially in the early morning.",
      "Myrh": "Harvested resin packed in jars and used in burials and perfumes. Carried by merchants and temple attendants alike.",
      "Oatmeal": "Coarsely ground oats boiled in water. A common meal at dawn, flavored with dates or honey when available.",
      "Olive_Oil": "Pressed from ripe olives and stored in clay jars. Used for cooking, lighting, and anointing in homes and sacred places.",
      "olives": "Picked from gnarled trees and preserved in brine. Served with bread or meat during meals and gatherings.",
      "Onion": "Dug from irrigated fields and added to stews. Stored in baskets through the winter and spring seasons.",
      "Onyx": "A banded black stone cut and polished for rings or amulets. Traded in artisan districts and port markets.",
      "Opal_Locket": "A clay pendant with a light, iridescent stone. Worn as ornamentation, often strung with flax or wool cord.",
      "Pear": "Grown in cooler highland groves and prized for its sweet flesh. Often eaten fresh or dried for storage.",
      "Philistine_Compact_Bow": "A short composite bow favored by Philistine archers. Quick to draw and deadly at close range.",
      "Philistine_Portable_Time_Dial": "A flat stone with etched markings. Used to track hours by shadow‚Äîrare and likely elite-made.",
      "Philistine_Pot": "A rounded cooking vessel with dark paint patterns. Common in coastal regions and often found in trade towns.",
      "Philistine_Tent_Spoke": "A wooden support beam carved with foreign symbols. Used in semi-permanent structures near the borderlands.",
      "Pile_of_rope": "Twisted from flax and goat hair, this rope is strong enough for hauling or securing tents and carts.",
      "Pinto_Beans": "Speckled legumes cooked slowly with oil. A hardy meal in times of scarcity or travel.",
      "Pita_in_stew": "Pieces of torn flatbread soaked in hot broth. Shared in communal pots during feasts and family gatherings.",
      "Pitcher_of_Water": "A ceramic jug filled with cool well water. Brought to guests upon arrival and poured into washing basins.",
      "Plain_Assyrian_Bracelet": "A simple bronze band with minimal engraving. Common among soldiers or craftsmen in foreign garrisons.",
      "Plain_Wafers": "Thin flat cakes baked without leaven. Served during fasts and sacred meals in temple courtyards.",
      "Pluot": "A hybrid of plum and apricot. Grown in small orchards and eaten during mid-summer when fruit is most ripe.",
      "Pomegranate_half": "Half of a fruit placed on clay dish. Served to guests or included as offering in sacred spaces.",
      "Pomegranate": "A thick-skinned fruit with deep red seeds. Often mentioned in early Hebrew poetry and temple carvings.",
      "Pomegranates": "A cluster of ripe fruit stored in baskets. Valued for sweetness and longevity in dry seasons.",
      "Porridge": "A warm mash of grain and milk, stirred slowly. Served before dawn or during winter in shepherd camps.",
      "Potatoes": "Unearthed from shaded fields and stored in root cellars. Roasted or boiled for daily meals.",
      "Purple_Fig": "A dark, juicy fig grown in low valleys. Split and dried under the sun, then packed in clay jars.",
      "Purple_Plums": "Grown near water-rich areas, these plums are tart and refreshing. Best eaten fresh under the midday sun.",
      "Rappier": "A long slender sword with a decorated hilt. Likely ceremonial or used in duels among tribal leaders.",
      "Raw_Beef": "Cuts of fresh meat prepared for cooking. Hung in shade to cure or quickly boiled in stew pots.",
      "Raw_Chicken": "Cleaned and dressed fowl ready for the fire. Often served with herbs in clay dishes or skewered over flame.",
      "Red_Grapes": "Grown near Hebron and pressed for wine or dried into raisins. Sold in markets or offered at weddings.",
      "Red_Pottage": "A lentil stew simmered with herbs and onion. Famously traded in stories for a birthright.",
      "Regular_Bow": "A basic bow made from local wood and sinew. Used by shepherds, hunters, and young warriors alike.",
      "Ruby": "A deep red stone found rarely in local trade. Set in bronze for necklaces or brooches in noble houses.",
      "Sage": "A soft-leafed herb used in both medicine and cooking. Grown near homes and temple gardens.",
      "Sapphire": "A blue gemstone used in signet rings and adornment. Imported through eastern trade routes in small quantities.",
      "Scroll_Basket": "A woven reed basket used to carry and protect scrolls. Found in temples or with traveling scribes.",
      "Seed_Oil_Flask": "A small clay container filled with oil from pressed seeds. Poured into lamps or used in healing ointments.",
      "Shallot": "A small, bulbous root with a sweet, sharp taste. Chopped and added to stews or dried for storage through winter.",
      "Shattered_Blade": "The fractured remains of a sword. Possibly broken during battle or symbolically buried after service.",
      "Shell": "Collected along the coast and traded inland. Used as ornamentation or strung into necklaces and charms.",
      "Shew_Bread": "Special loaves placed on sacred tables in the temple. Baked without leaven and replaced weekly by priests.",
      "Shrimp": "Net-caught in shallow coastal waters and dried in the sun. Rare inland, but occasionally brought by sea traders.",
      "Slashing_Dagger": "A curved, close-range weapon with a simple grip. Used by scouts or kept hidden among garments.",
      "Smooth_Stones": "River stones chosen for their size and balance. Used in slings by shepherds or for marking boundaries.",
      "Spoke": "A wooden beam used in carts and tents. Essential for mobility, trade, and travel across rough terrain.",
      "Staff_of_Moses": "A carved walking staff associated with ancient leadership. Often recreated as a symbol of guidance and deliverance.",
      "Stone_Assyrian_Fish_God_Carving": "A relic from northern lands, depicting Dagon‚Äîpart man, part fish. Evidence of foreign altars among ruins.",
      "Sun_Shell": "A bright-patterned shell with ridges like rays. Collected near the coast and kept as a keepsake.",
      "Table_grapes": "Fresh grapes served on platters at feasts. Common in vineyards around Hebron and enjoyed in late summer.",
      "Tablet_1": "An ancient tablet incribed with instructions on how to find a secret treasure- Ehud's Dagger. Perhaps striking without being seen may yield unexpected results.",
      "tablet_10": "An ancient tablet incribed with instructions on how to find a secret treasure- Nehushtan (Moses' Bronze serpant). Perhaps it might still serve it's original purpose",
      "tablet_11": "An ancient tablet incribed with instructions on how to find a secret treasure- Abraham's knife. If ever in a bind- divine intervention might turn the tide",
      "Tablet_12": "An ancient tablet incribed with instructions on how to find a secret treasure- the Horn of Annointing. Oil is known to have some healing properties.",
      "Tablet_13": "An ancient tablet incribed with instructions on how to find a secret treasure- the spear of Phinehas. Justice is served with a swift hand, just make sure to keep your distance.",
      "tablet_14": "An ancient tablet incribed with instructions on how to find a secret treasure- Joseph's Coat. Why am I feeling so sleepy reading this?",
      "tablet_15": "An ancient tablet incribed with instructions on how to find a secret treasure- The Rod of Moses. Something tells me this will be quite handy when it comes to travel.",
      "Tablet_16": "An ancient tablet incribed with instructions on how to find a secret treasure- Miriam's timbrel- I wonder what good some music can do?",
      "Tablet_19": "An ancient tablet incribed with instructions on how to find a secret treasure- Rahab's cord. May come in handy if you ever need a way out.",
      "Tablet_2": "An ancient tablet incribed with instructions on how to find a secret treasure- Gideon's torch. Perhaps it may it's light may turn darkness into light.",
      "tablet_20": "An ancient tablet incribed with instructions on how to find a secret treasure- The Sword of Eden- be carefull though. This treasure may have an unexpected surprise.",
      "Tablet_3": "An ancient tablet incribed with instructions on how to find a secret treasure- Gideon's horn. This horn may be quite confusing to those who hear it.",
      "tablet_4": "An ancient tablet incribed with instructions on how to find a secret treasure- Shamgar's ox goad. This tool may prove useful in the right hands- for plowing and for more.",
      "Tablet_5": "An ancient tablet incribed with instructions on how to find a secret treasure- Samson's jawbone. Its time to thin down the crowd.",
      "Tablet_6": "An ancient tablet incribed with instructions on how to find a secret treasure- Samson's hair- if anything can bring down the house- this is it.",
      "tablet_7": "An ancient tablet incribed with instructions on how to find a secret treasure- Jael's tent peg. If you thought all it took was strength to win a battle, think again.",
      "Tablet_8": "An ancient tablet incribed with instructions on how to find a secret treasure- Cain's Cudgel. Revenge is a dish best served cold- or with a cudgel.",
      "tablet_9": "An ancient tablet incribed with instructions on how to find a secret treasure- Horn of Jericho. If your looking to break some walls- you better have some inner gall",
      "tablets_17___18": "An ancient tablet incribed with instructions on how to find a secret treasure- the Urim and Thummim. Perhaps this might prove useful in finding hidden treasure.",
      "Tent_Spoke": "A long wooden rod used to support tent frames. Essential gear for travelers and herders.",
      "The_fiery_Pheonix": "A decorative carving of a bird in flames. Possibly symbolic or imported‚Äîlinked to eastern legends.",
      "THe_Historical_Scrolls": "A bundled collection of written history. Preserved in a clay jar and passed between scribes.",
      "The_Poetry_Scrolls": "Scrolls containing village songs and proverbs. Read during festivals and oral storytelling sessions.",
      "The_Prophetic_Scrolls": "Contains early prophetic messages copied by scribes. Found in dry caves sealed with wax.",
      "The_torrah_Basket": "A woven container designed to hold sacred writings. Carried with care during migration or conflict.",
      "Throwing_Blade": "A small, balanced blade with sharpened edges. Used in contests or as a concealed weapon.",
      "Throwing_Dart": "A lightweight dart tipped with iron. Practiced by young warriors aiming at targets outside the village.",
      "Topaz": "A golden gem cut from river rock. Polished and set into decorative items found in market stalls.",
      "Zircon": "A clear, diamond-like stone with brilliant facets. Rare in this region and typically acquired through distant trade routes."
    };

  let imageCounter = 1;

  function simplifyImageName(filename) {
      // Count words separated by spaces, underscores, or hyphens
      const words = filename.replace(/\.[^/.]+$/, "") // Remove extension
                            .split(/[\s_-]+/) // Split by spaces, underscores, hyphens
                            .filter(word => word.length > 0);
      
      if (words.length > 4) {
        return `Image ${imageCounter++}`;
      }
      return `Image ${imageCounter++}`;
    }

    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        if (section.style.display === 'none' || section.style.display === '') {
          section.style.display = 'block';
          section.classList.add('show');
        } else {
          section.style.display = 'none';
          section.classList.remove('show');
        }
      }
    }

  function createImageCard(imagePath, displayName, imageId) {
      const filename = imagePath.split('/').pop();
      const encodedPath = imagePath
        .split('/')
        .map(segment => encodeURIComponent(segment))
        .join('/');
      const matchedData = findMatchingDescription(filename);
      
      // Pre-populate name and description if found
      const defaultName = matchedData ? matchedData.name : '';
      const defaultDescription = matchedData ? matchedData.description : '';
      
      return `
        <div class="image-survey-card" onclick="toggleZoom(this)">
          <div class="image-container">
            <img src="/${encodedPath}" alt="${displayName}" loading="lazy">
            <div class="image-filename">${displayName}</div>
          </div>
          <div class="card-content">
            <div class="survey-controls">
              <div class="checkbox-row">
                <input type="checkbox" id="good_${imageId}" name="rating_${imageId}" value="good" onclick="event.stopPropagation()">
                <label for="good_${imageId}">Looks good</label>
              </div>
              <div class="checkbox-row">
                <input type="checkbox" id="unsure_${imageId}" name="rating_${imageId}" value="unsure" onclick="event.stopPropagation()">
                <label for="unsure_${imageId}">I'm not sure</label>
              </div>
              <input type="text" class="text-input name-input" placeholder="Name recommendation (20 chars max)" maxlength="20" name="name_${imageId}" data-image-id="${imageId}" value="${defaultName}" data-original-value="${defaultName}" onclick="event.stopPropagation()">
              <textarea class="text-input description-input" placeholder="Description recommendation (40 words max)" name="description_${imageId}" data-image-id="${imageId}" data-original-value="${defaultDescription}" onclick="event.stopPropagation()">${defaultDescription}</textarea>
            </div>
          </div>
        </div>
      `;
    }

  function generateFolderStructure(data, basePath = '', level = 1) {
      let html = '';
      let globalImageId = 1;

      function processFolder(folderData, currentPath, currentLevel, folderName = '') {
        let folderHtml = '';
        
        if (folderName) {
          const headingTag = `h${Math.min(currentLevel, 6)}`;
          const sectionId = `section_${currentPath.replace(/[^a-zA-Z0-9]/g, '_')}`;
          
          folderHtml += `
            <div class="folder-section">
              <${headingTag} class="folder-header" onclick="toggleSection('${sectionId}')">${folderName}</${headingTag}>
              <div id="${sectionId}" class="collapsible-content">
          `;
        }

        // Process images in current folder
        if (folderData.images && folderData.images.length > 0) {
          folderHtml += '<div class="images-grid">';
          folderData.images.forEach(imageName => {
            const imagePath = currentPath ? `${currentPath}/${imageName}` : imageName;
            const displayName = simplifyImageName(imageName);
            folderHtml += createImageCard(imagePath, displayName, globalImageId++);
          });
          folderHtml += '</div>';
        }

        // Process subfolders
        if (folderData.subfolders) {
          Object.entries(folderData.subfolders).forEach(([subfolderName, subfolderData]) => {
            const subfolderPath = currentPath ? `${currentPath}/${subfolderName}` : subfolderName;
            folderHtml += processFolder(subfolderData, subfolderPath, currentLevel + 1, subfolderName);
          });
        }

        if (folderName) {
          folderHtml += `
              </div>
            </div>
          `;
        }

        return folderHtml;
      }

      // Start processing from root
      Object.entries(data).forEach(([rootFolderName, rootFolderData]) => {
        html += processFolder(rootFolderData, rootFolderName, level, rootFolderName);
      });

      return html;
    }

    function countWords(text) {
      return text.trim().split(/\s+/).filter(word => word.length > 0).length;
    }

    function validateDescriptions() {
      const descriptions = document.querySelectorAll('.description-input');
      descriptions.forEach(textarea => {
        textarea.addEventListener('input', function() {
          const wordCount = countWords(this.value);
          if (wordCount > 40) {
            const words = this.value.trim().split(/\s+/);
            this.value = words.slice(0, 40).join(' ');
          }
        });
      });
    }

    function setupCheckboxExclusivity() {
      const checkboxPairs = document.querySelectorAll('.image-survey-card');
      checkboxPairs.forEach(card => {
        const goodCheckbox = card.querySelector('input[value="good"]');
        const unsureCheckbox = card.querySelector('input[value="unsure"]');
        
        if (goodCheckbox && unsureCheckbox) {
          goodCheckbox.addEventListener('change', function() {
            if (this.checked) {
              unsureCheckbox.checked = false;
            }
          });
          
          unsureCheckbox.addEventListener('change', function() {
            if (this.checked) {
              goodCheckbox.checked = false;
            }
          });
        }
      });
    }

    function collectSurveyData() {
      const data = [];
      const cards = document.querySelectorAll('.image-survey-card');
      
      cards.forEach((card, index) => {
        const img = card.querySelector('img');
        const filename = img.src.split('/').pop();
        const imagePath = img.getAttribute('src') || '';
        const displayName = card.querySelector('.image-filename').textContent;
        
        const goodChecked = card.querySelector('input[value="good"]')?.checked || false;
        const unsureChecked = card.querySelector('input[value="unsure"]')?.checked || false;
        
        const nameInput = card.querySelector('.name-input');
        const descriptionInput = card.querySelector('.description-input');
        
        const nameRecommendation = nameInput?.value || '';
        const descriptionRecommendation = descriptionInput?.value || '';
        
        // Get original auto-populated values
        const originalName = nameInput?.dataset.originalValue || '';
        const originalDescription = descriptionInput?.dataset.originalValue || '';
        
        // Check if values were changed from original auto-populated values
        const nameChanged = nameRecommendation !== originalName;
        const descriptionChanged = descriptionRecommendation !== originalDescription;
        
        let rating = 'no_rating';
        if (goodChecked) rating = 'good';
        else if (unsureChecked) rating = 'not_sure';
        
        data.push({
          originalFilename: filename,
          imagePath: imagePath,
          displayName: displayName,
          rating: rating,
          nameRecommendation: nameRecommendation,
          descriptionRecommendation: descriptionRecommendation,
          nameChanged: nameChanged,
          descriptionChanged: descriptionChanged,
          wasAutoPopulated: originalName !== '' || originalDescription !== ''
        });
      });
      
      return data;
    }

    function setStatus(msg, type = 'info') {
      const el = document.getElementById('survey-status');
      if (!el) return;
      const colors = { info: '#ccc', success: '#7dd3fc', error: '#fda4af', warn: '#fde68a' };
      el.style.color = colors[type] || '#ccc';
      el.textContent = msg;
    }

    async function checkAPI() {
      try {
        const url = `/api/survey-api.php?action=list_pending&_=${Date.now()}`;
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) {
          setStatus(`API HTTP error ${res.status}. Submissions may fail.`, 'warn');
          return false;
        }
        const ct = (res.headers.get('content-type') || '').toLowerCase();
        if (ct.includes('application/json')) {
          const j = await res.json();
          if (j && j.success) {
            setStatus('API online. You can submit changes.', 'success');
            return true;
          } else {
            setStatus('API reachable but returned an error. Submissions may fail.', 'warn');
            return false;
          }
        } else {
          const text = await res.text();
          const snippet = text.slice(0, 120);
          setStatus(`API returned non-JSON (likely static hosting). Submissions will not work. Snippet: ${snippet}`, 'error');
          return false;
        }
      } catch (e) {
        setStatus('API not reachable. Are you running PHP? Submissions will not work on static hosting.', 'error');
        return false;
      }
    }

    async function attemptSubmitViaGet(changesForApproval) {
      try {
        const qs = `action=submit_changes&changes=${encodeURIComponent(JSON.stringify(changesForApproval))}`;
        const full = `/api/survey-api.php?${qs}`;
        if (full.length > 1900) {
          throw new Error('Payload too large for GET fallback. Please run on PHP server to use POST.');
        }
        const res = await fetch(full, { cache: 'no-store' });
        if (!res.ok) {
          const txt = await res.text();
          throw new Error(`GET fallback failed: HTTP ${res.status}. ${txt.slice(0,200)}`);
        }
        const ct = (res.headers.get('content-type') || '').toLowerCase();
        if (!ct.includes('application/json')) {
          const txt = await res.text();
          throw new Error(`GET fallback non-JSON: ${txt.slice(0,200)}`);
        }
        const data = await res.json();
        if (data && data.success) {
          setStatus('Submitted via GET fallback. Open the admin portal to approve/deny.', 'success');
          alert('Submitted for review (GET fallback). Your proposed changes are now pending in the admin portal.');
          return true;
        } else {
          throw new Error(data && data.message ? data.message : 'Unknown error');
        }
      } catch (e) {
        setStatus('Submission failed via GET fallback: ' + e.message, 'error');
        return false;
      }
    }

    function submitSurvey() {
      const surveyData = collectSurveyData();
      
      // Filter to only include items with actual data or changes to auto-populated content
      const changedItems = surveyData.filter(item => {
        // Include if there's a rating
        if (item.rating !== 'no_rating') return true;
        
        // Include if it's manually entered content (not auto-populated)
        if (!item.wasAutoPopulated && (item.nameRecommendation || item.descriptionRecommendation)) {
          return true;
        }
        
        // Include if auto-populated content was changed
        if (item.wasAutoPopulated && (item.nameChanged || item.descriptionChanged)) {
          return true;
        }
        
        return false;
      });
      
      if (changedItems.length === 0) {
        setStatus('Nothing to submit. Please add a name and/or description recommendation before submitting.', 'warn');
        alert('Please provide at least one name or description recommendation before submitting.');
        return;
      }
      
      // Store data for recovery - keep the data after submission
      localStorage.setItem('latestSurveyData', JSON.stringify({
        timestamp: new Date().toISOString(),
        data: changedItems
      }));

      // Send changes to change-management system for approval
      const changesForApproval = changedItems.map(item => ({
        filename: item.originalFilename,
        imagePath: item.imagePath,
        displayName: item.displayName,
        newName: item.nameRecommendation,
        newDescription: item.descriptionRecommendation,
        submittedAt: new Date().toISOString()
      })).filter(item => item.newName || item.newDescription);

      if (changesForApproval.length > 0) {
        setStatus('Submitting changes‚Ä¶');
        fetch('/api/survey-api.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `action=submit_changes&changes=${encodeURIComponent(JSON.stringify(changesForApproval))}`
        })
        .then(async res => {
          if (!res.ok) {
            const txt = await res.text();
            throw new Error(`HTTP ${res.status}. ${txt.slice(0, 200)}`);
          }
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          if (!ct.includes('application/json')) {
            const txt = await res.text();
            throw new Error(`Non-JSON response. ${txt.slice(0, 200)}`);
          }
          return res.json();
        })
        .then(data => {
          if (data.success) {
            setStatus('Submitted for review. Open the admin portal to approve/deny.', 'success');
            alert('Submitted for review. Your proposed changes are now pending in the admin portal.');
          } else {
            setStatus('Failed to submit: ' + (data.message || 'Unknown error'), 'error');
            alert('Failed to submit changes for review: ' + data.message);
          }
        })
        .catch(async err => {
          const msg = String(err || '');
          // Try GET fallback if POST not allowed or blocked
          if (msg.includes('HTTP 405') || msg.includes('HTTP 404') || msg.includes('Non-JSON')) {
            setStatus('POST failed (' + msg + '). Trying GET fallback‚Ä¶', 'warn');
            const ok = await attemptSubmitViaGet(changesForApproval);
            if (!ok) {
              alert('Network error submitting changes for review: ' + msg);
            }
          } else {
            setStatus('Network/API error: ' + msg + '. Are you running PHP backend?', 'error');
            alert('Network error submitting changes for review: ' + msg);
          }
        });
      } else {
        setStatus('No name or description changes to submit.', 'warn');
        alert('No name or description changes to submit.');
      }
    }

    // Auto-save data and prompt on page unload
    window.addEventListener('beforeunload', function(e) {
      const surveyData = collectSurveyData();
      const changedItems = surveyData.filter(item => 
        item.rating !== 'no_rating' || 
        item.nameRecommendation || 
        item.descriptionRecommendation
      );
      
      if (changedItems.length > 0) {
        // Always save current work
        saveCurrentWork(changedItems);
        
        // Check if we should prompt for submission
        const hasPromptedBefore = localStorage.getItem('hasPromptedSubmission');
        if (!hasPromptedBefore) {
          // Set the flag immediately to prevent multiple prompts
          localStorage.setItem('hasPromptedSubmission', 'true');
          
          // Create prompt message
          e.preventDefault();
          e.returnValue = 'You have unsaved survey responses. Would you like to submit them before leaving?';
          return e.returnValue;
        }
      }
    });

    // Auto-save functionality for real-time data persistence
    function saveCurrentWork(changedItems = null) {
      const surveyData = changedItems || collectSurveyData();
      const itemsWithData = surveyData.filter(item => 
        item.rating !== 'no_rating' || 
        item.nameRecommendation || 
        item.descriptionRecommendation
      );
      
      if (itemsWithData.length > 0) {
        const saveData = {
          timestamp: new Date().toISOString(),
          data: itemsWithData,
          formData: collectFormFieldValues(),
          type: 'auto-save'
        };
        localStorage.setItem('surveyWorkInProgress', JSON.stringify(saveData));
      } else {
        // Remove saved data if nothing is filled out
        localStorage.removeItem('surveyWorkInProgress');
      }
    }

    // Collect current form field values for restoration
    function collectFormFieldValues() {
      const formData = {};
      const cards = document.querySelectorAll('.image-survey-card');
      
      cards.forEach((card, index) => {
        const img = card.querySelector('img');
        const filename = img.src.split('/').pop();
        
        const goodChecked = card.querySelector('input[value="good"]')?.checked || false;
        const unsureChecked = card.querySelector('input[value="unsure"]')?.checked || false;
        const nameValue = card.querySelector('.name-input')?.value || '';
        const descriptionValue = card.querySelector('.description-input')?.value || '';
        
        if (goodChecked || unsureChecked || nameValue || descriptionValue) {
          formData[filename] = {
            goodChecked,
            unsureChecked,
            nameValue,
            descriptionValue
          };
        }
      });
      
      return formData;
    }

    // Restore form field values
    function restoreFormFieldValues(formData) {
      const cards = document.querySelectorAll('.image-survey-card');
      
      cards.forEach((card) => {
        const img = card.querySelector('img');
        const filename = img.src.split('/').pop();
        
        if (formData[filename]) {
          const data = formData[filename];
          
          const goodCheckbox = card.querySelector('input[value="good"]');
          const unsureCheckbox = card.querySelector('input[value="unsure"]');
          const nameInput = card.querySelector('.name-input');
          const descriptionInput = card.querySelector('.description-input');
          
          if (goodCheckbox) goodCheckbox.checked = data.goodChecked;
          if (unsureCheckbox) unsureCheckbox.checked = data.unsureChecked;
          if (nameInput) nameInput.value = data.nameValue;
          if (descriptionInput) descriptionInput.value = data.descriptionValue;
        }
      });
    }

    // Auto-save every 30 seconds when user is actively working
    let autoSaveInterval;
    function startAutoSave() {
      if (autoSaveInterval) clearInterval(autoSaveInterval);
      autoSaveInterval = setInterval(() => {
        saveCurrentWork();
      }, 30000); // Save every 30 seconds
    }

    // Clear all form fields with notification
    function clearAllFields() {
      if (confirm('Are you sure you want to clear all survey responses? This action cannot be undone.')) {
        if (confirm('This will permanently delete all your current responses. Continue?')) {
          const cards = document.querySelectorAll('.image-survey-card');
          
          cards.forEach((card) => {
            const goodCheckbox = card.querySelector('input[value="good"]');
            const unsureCheckbox = card.querySelector('input[value="unsure"]');
            const nameInput = card.querySelector('.name-input');
            const descriptionInput = card.querySelector('.description-input');
            
            if (goodCheckbox) goodCheckbox.checked = false;
            if (unsureCheckbox) unsureCheckbox.checked = false;
            if (nameInput) nameInput.value = '';
            if (descriptionInput) descriptionInput.value = '';
          });
          
          // Clear saved data
          localStorage.removeItem('surveyWorkInProgress');
          localStorage.removeItem('hasPromptedSubmission');
          
          // Send notification about clearing data
          sendClearNotification();
          
          alert('All survey responses have been cleared.');
        }
      }
    }

    // Send notification when data is cleared
    async function sendClearNotification() {
      // Email notifications disabled by request; no-op
      console.log('Survey data cleared (notification suppressed).');
    }

    // Check for auto-saved data on page load and automatically restore
    function checkForAutoSavedData() {
      // Check for work in progress
      const workInProgress = localStorage.getItem('surveyWorkInProgress');
      if (workInProgress) {
        try {
          const data = JSON.parse(workInProgress);
          const timeDiff = Date.now() - new Date(data.timestamp).getTime();
          const hoursDiff = timeDiff / (1000 * 60 * 60);
          
          if (hoursDiff < 72) { // Keep work for up to 3 days
            // Automatically restore previous work without asking
            setTimeout(() => {
              if (data.formData) {
                restoreFormFieldValues(data.formData);
              }
            }, 500);
            return;
          } else {
            // Remove old data
            localStorage.removeItem('surveyWorkInProgress');
            localStorage.removeItem('hasPromptedSubmission');
          }
        } catch (error) {
          console.error('Error parsing work in progress:', error);
          localStorage.removeItem('surveyWorkInProgress');
        }
      }

      // Check for old auto-saved data and clean it up automatically
      const autoSaved = localStorage.getItem('autoSurveyData');
      if (autoSaved) {
        try {
          // Legacy auto-saved data found; clear it without emailing
          localStorage.removeItem('autoSurveyData');
        } catch (error) {
          console.error('Error clearing legacy auto-saved data:', error);
          localStorage.removeItem('autoSurveyData');
        }
      }
    }


    // Initialize the survey when page loads
    document.addEventListener('DOMContentLoaded', function() {
      // Check for auto-saved data first
      checkForAutoSavedData();

  const surveyContent = document.getElementById('survey-content');
  checkAPI();

      function afterRender() {
        // Setup form validation and interactions
        validateDescriptions();
        setupCheckboxExclusivity();
        // Start auto-save functionality
        startAutoSave();
        // Add event listeners for real-time saving when user interacts with form
        setTimeout(() => {
          const inputs = document.querySelectorAll('input[type="checkbox"], input.name-input, textarea.description-input');
          inputs.forEach(input => {
            input.addEventListener('change', () => saveCurrentWork());
            if (input.type === 'text' || input.tagName === 'TEXTAREA') {
              input.addEventListener('blur', () => saveCurrentWork());
            }
          });
        }, 500);
        // Show root level by default
        const rootSections = document.querySelectorAll('[id^="section_Game_pixel_art"]');
        rootSections.forEach(section => {
          if (section.id === 'section_Game_pixel_art') {
            section.style.display = 'block';
            section.classList.add('show');
          }
        });
      }

      // Prefer generated JSON of actual files; fall back to bundled database
      fetch('/assets/data/game-pixel-art.json')
        .then(r => r.ok ? r.json() : Promise.reject(new Error('No JSON')))
        .then(db => {
          surveyContent.innerHTML = generateFolderStructure(db);
          afterRender();
        })
        .catch(() => {
          try {
            if (typeof imageDatabase !== 'undefined') {
              surveyContent.innerHTML = generateFolderStructure(imageDatabase);
            } else {
              surveyContent.innerHTML = '<p style="color:white">No image database available.</p>';
            }
          } catch (e) {
            surveyContent.innerHTML = '<p style="color:white">Failed to load images.</p>';
          }
          afterRender();
        });
    });

    // Toggle all sections expand/collapse
    function toggleAllSections() {
      const button = document.querySelector('.expand-all-button');
      const allSections = document.querySelectorAll('.collapsible-content');
      const isExpanding = button.textContent === 'Expand All';
      
      allSections.forEach(section => {
        if (isExpanding) {
          section.style.display = 'block';
          section.classList.add('show');
        } else {
          section.style.display = 'none';
          section.classList.remove('show');
        }
      });
      
      button.textContent = isExpanding ? 'Collapse All' : 'Expand All';
    }

    // Mobile zoom functionality
    function toggleZoom(card) {
      if (window.innerWidth <= 768) {
        const overlay = document.querySelector('.zoom-overlay');
        const isZoomed = card.classList.contains('zoomed');
        
        if (isZoomed) {
          closeZoom();
        } else {
          // Close any other zoomed cards
          document.querySelectorAll('.image-survey-card.zoomed').forEach(c => c.classList.remove('zoomed'));
          
          // Zoom this card
          card.classList.add('zoomed');
          overlay.classList.add('active');
          document.body.style.overflow = 'hidden';
        }
      }
    }

    function closeZoom() {
      const overlay = document.querySelector('.zoom-overlay');
      const zoomedCards = document.querySelectorAll('.image-survey-card.zoomed');
      
      zoomedCards.forEach(card => card.classList.remove('zoomed'));
      overlay.classList.remove('active');
      document.body.style.overflow = 'auto';
    }
  </script>
</body>
</html>
